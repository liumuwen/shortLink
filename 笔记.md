## 20260131
### hosts配置了但是短链接仍然没有效果
* 梯子的原因
## 20260201
### 短链接创建过程(布隆过滤器创建--分布式锁创建)
```cpp
布隆过滤器创建流程
1 白名单校验
2 生成短链后缀
   ├ 布隆过滤器判断
   └ 冲突重试
3 构建短链主表对象
4 构建路由表对象(goto)
5 插入数据库
   ├ 成功 → 继续
   └ 失败 → 判重 + 报错
6 Redis缓存预热
7 写入布隆过滤器
8 返回短链
```
这里为什么需要路由表（避免分片的情况下全库扫描，通过路由表可以快速定位到具体的分片）
### 短链接更新过程
```cpp
开始
  │
  ▼
1. 白名单校验
  │
  ▼
2. 查询原短链（gid + fullShortUrl + delFlag=0 + enableStatus=0）
  │
  ▼
3. 判断是否存在
  ├─ 不存在 → 抛异常，流程终止
  └─ 存在 → 继续
        │
        ▼
4. 判断 gid 是否变化
  ├─ gid 未变化 → 普通更新
  │      │
  │      ▼
  │   4.1 构建更新条件和 ShortLinkDO 对象
  │      │
  │      ▼
  │   4.2 执行数据库 UPDATE
  │      │
  │      ▼
  │   4.3 删除缓存（正缓存 & 负缓存，根据字段变化）
  │
  └─ gid 已变化 → 跨分片迁移
         │
         ▼
     4.1 加分布式写锁（短链粒度）
         │
         ▼
     4.2 逻辑删除旧短链（delFlag=1, delTime=now）
         │
         ▼
     4.3 构建新 ShortLinkDO 并插入新记录
         │
         ▼
     4.4 迁移 ShortLinkGotoDO（删除旧记录 → 更新 gid → 插入新记录）
         │
         ▼
     4.5 释放写锁
         │
         ▼
5. 删除缓存（正缓存 & 负缓存，根据字段变化）
  │
  ▼
结束
```
### 短链接查询
```cpp
开始
  │
  ▼
1. 构建 fullShortUrl
  │
  ▼
2. 查询正缓存（GOTO_SHORT_LINK_KEY）
  ├─ 命中 → 记录统计 → 跳转 originalLink → 结束
  └─ 未命中
          │
          ▼
3. 布隆过滤器判断（shortUriCreateCachePenetrationBloomFilter.contains）
  ├─ 不存在 → 跳转 "/page/notfound" → 结束
  └─ 存在
          │
          ▼
4. 查询负缓存（GOTO_IS_NULL_SHORT_LINK_KEY）
  ├─ 命中 → 跳转 "/page/notfound" → 结束
  └─ 未命中
          │
          ▼
5. 获取分布式锁（LOCK_GOTO_SHORT_LINK_KEY）
          │
          ▼
6. 再次查询正缓存（Double Check）
  ├─ 命中 → 记录统计 → 跳转 originalLink → 结束
  └─ 未命中
          │
          ▼
7. 再次查询负缓存
  ├─ 命中 → 跳转 "/page/notfound" → 结束
  └─ 未命中
          │
          ▼
8. 查询 ShortLinkGotoDO 表（路由表）
  ├─ 不存在 → 设置负缓存 GOTO_IS_NULL_SHORT_LINK_KEY → 跳转 "/page/notfound" → 结束
  └─ 存在
          │
          ▼
9. 查询 ShortLinkDO 表（主表，条件：gid + fullShortUrl + delFlag=0 + enableStatus=0）
  ├─ 不存在或已过期 → 设置负缓存 GOTO_IS_NULL_SHORT_LINK_KEY → 跳转 "/page/notfound" → 结束
  └─ 存在
          │
          ▼
10. 设置正缓存 GOTO_SHORT_LINK_KEY（缓存有效时间 = 链接过期时间）
          │
          ▼
11. 记录访问统计（shortLinkStats）
          │
          ▼
12. 重定向到原始长链（originalLink）
          │
          ▼
13. 释放分布式锁 → 结束
```
布隆过滤器 + 空对象缓存 → 防穿透；分布式锁 + 双重缓存检查 → 防击穿；数据库仅在必要时查询

数据库查询时就用到了路由表，监控统计用分布式锁异步来做
### 回收站管理
*（增删查改 链接恢复 enable字段的变化 delete字段的变化而已）
### 数据监控
* 一个是报表产生，统计聚合，一个是查每次访问记录（分页）
* 三类表：访问明细表  pv|uv等统计表  设备表，浏览器表等

## 20260202
### 压测记录
| 参数(线程x循环） | 吞吐量  |
|:---------:|:----:|
| 40 x 100  | 3127 |
| 4000 x 1  | 1367 |
------引入消息队列-------
| 参数(线程x循环） | 吞吐量  |
|:---------:|:----:|
| 40 x 200  | 3170 |
| 80 x 100  | 3200 |
| 100 x 100 | 2900 |

## 20260203
### 加入读写锁的目的是什么
在短链接中，存在可以并发的高频的访问统计请求和低频的分组修改请求，两者不能并发进行，不然可能导致短链接拿到错误的分组

这就很合适用读写锁，写锁加在分组修改，读锁加在访问统计

## 20260204
### openresty限流
* 黑名单检查
Redis 中存了被封 IP，发现匹配则直接 403 拒绝。

有效期为 BLACK_LIST_TTL = 600 秒。
* 白名单检查

Redis 中存了白名单 IP，匹配则直接放行，不走后续限流。

* 拉黑函数
当 IP 或 Token 被限流拒绝时，触发封禁 10 分钟。

* Token 限流
针对请求带 Authorization 的用户（通常是已登录或带 token 的请求）。

使用 令牌桶算法（resty.limit.req），控制每个 token 的请求速率和突发。
* IP 限流
针对所有请求，按客户端 IP 做全局限流。

同样使用 令牌桶算法，控制每个 IP 的请求速率和突发。
* Redis 支持
黑白名单依赖 Redis。

Redis 连接池管理，提高性能

### sentinel
根据压测的结果限流 3k+ * 0.8
